#!/bin/bash
#
# setup-tpch-db
#
# A script for setting up a MonetDB database containing the schema for
# the US Department of Transport's on-time flight statistics, for the benchmark
# described here:
#
# https://www.percona.com/blog/2009/10/02/analyzing-air-traffic-performance-with-infobright-and-monetdb/
#
# Must be run after MonetDB itself has been properly installed
# 
#################################################################################
# By Eyal Rozenberg <E.Rozenberg@cwi.nl>
# version: 2016-10-26
# If you want to talk copyrights and stuff, write me
##################################################################################
#
# BUGS: Not noticing DB farm is up, trying to start another monetdbd
#
# TODO: 
# - Support loading into a DB on a remote host (in which case we would not check)
#   for the existence of a DB farm
# - Support the option to create all columns non-null  (need to handle missing
#   integer fields)
# - Issue: What about authentication? Currently assuming user takes care of that
#   or has an appropriate .monetdb file
# - Feature: Download, build and install MonetDB itself if it is unavailable 
# - Feature: Differential operation after a setup process has been interrupted,
#   removing all records for the "partial" month and reloading all of them from
#   that month's files
# - Relax free space constraints somewhat, based on a more accurate estimate
#   of how much space will actually be taken up by the data
# - Log to a file in addition to stdout?


#---------------------------------------
# Constants and defaults

today=$(date +%Y-%m-%d)
this_year=$(date +%-Y)
this_month=$(date +%-m)
first_year_with_data=1987
first_month_with_data=1
publication_delay_months=2 # check that!
last_year_with_data=$(( this_month > publication_delay_months ? this_year : last_year - 1))
last_month_with_data=$(( this_month > publication_delay_months ? this_month - publication_delay_months : this_month + 12 - publication_delay_months ))
estimated_data_per_month_mb=200
download_dir="$PWD/usdt-ontime-downloads"
db_name="usdt-ontime"
table_name="ontime"
db_farm_port=50000
empty_as_null=1 # NOT NULL'ing columns is currently unsupported due to trouble with missing integer values
hostname=localhost

#------------------------------
# Helper functions

function usage {
	AUTHOR="Eyal Rozenberg"
	CONTACT_EMAIL="E.Rozenberg@cwi.nl"
	echo "Usage: $0 [OPTIONS]..."
	echo "Use MonetDB to creates and populate a database of the US Department of Transport's "
	echo "On-time perfromance data collected by the Beureau of Transport Statistics (and availabe "
	echo "on their website: http://www.transtats.bts.gov/DL_SelectFields.asp?Table_ID=236 )"
	echo 
	echo "Options:"
	echo "  -r, --recreate           If the benchmark database exists, recreate it, dropping all"
	echo "                           existing data. (If neither recreate nor append are set, the "
	echo "                           database be missing.)"
	echo "  -a, --append             If the benchmark database exists, append to it rather than"
	echo "                           recreating it. (If neither recreate nor append are set, the "
	echo "                           database be missing.)"
	echo "  -d, --db-name NAME       Name of the database holding on-time performance data"
	echo "  -f, --db-farm PATH       Filesystem path for the root directory of the MonetDB"
	echo "                           database farm in which to place the database"
	echo "  -p, --port NUMBER        Network port on the local host, which the server"
	echo "                           will related to the DB farm"
	echo "  -k, --keep-downloads     Keep the zipped CSV files downloaded from the US department"
	echo "                           of transport's website after loading them into the DB"
	echo "  -h, --help               Print usage information"
	echo "  -v, --verbose            Be verbose about actions taken and current status"
#	echo "  -n, --empty-as-null      Interpret empty fields as having a null value (rather than"
#	echo "                           an empty string or a 0 integer value)"
	echo "  -D, --download-dir       Directory into which individual monthly data file will be
        echo "                           downloaded and decompressed before being loaded into the DB
        echo "                           (default: $download_dir)"
	echo "  --first-year             First year for which to download data"
	echo "  --first-month            First month in first year for which to download data"
	echo "  --last-year              Last year for which to download data"
	echo "  --last-month             Last month in last year for which to download data"
	echo 
	echo "For questions and details, contact $AUTHOR <$CONTACT_EMAIL> (or just read the source)."
}

function die {
	echo $1 >&2   # error message to stderr 
	exit ${2:-1}  # default exit code is -1 but you can specify something else
}

function mb_available_space_for_dir {
	# Note this returns the number of 2^30 bytes, not 10^9
	 df --block-size=M --output=avail $1 | tail -1 | grep -o "[0-9]*"
}

function is_positive_int {
	[[ $1 =~ ^[0-9]+$ ]] && [[ ! $1 =~ ^0+$ ]]
}

# (monetdb's command-line utilities are not so great
# at reporting the status of things in machine-readable format)

function db_farm_exists {
	[[ $(monetdbd get all $1 2>/dev/null | wc -l)  -ne 0 ]]
}

function property_of_dbfarm {
	local property_name="$1"
	local db_farm="$2"
	monetdbd get $property_name $db_farm | tail -1 | sed "s/$property_name *//;"
}

function db_farm_is_up {
	db_farm="$1"
	# When a DB farm is up, the status is "monetdbd[process num here] version here (release name here) is serving this dbfarm";
	# when it's down, the status is "no monetdbd is serving this dbfarm"
	[[ $(property_of_dbfarm status $1) =~ "monetdbd[" ]]
}

function db_is_up {
	# This assumes the DB exists
	local db_name=$1
	local port=$2
	[[ $(monetdb -p $port status $db_name 2>/dev/null | wc -l) > 0 ]]
	status=$(monetdb status $db_name | tail -1 | sed -r 's/^'$db_name'\s*([^ ]*).*$/\1/;')
	[[ $status == "R" ]]
}


function db_exists {
	local db_name=$1
	local port=$2
	[[ $(monetdb -p $port status $db_name 2>/dev/null | wc -l) > 0 ]]
}

function run_mclient {
	local language="sql"
#	local db_name="$1"
	local query="$1"
	local format="${2:-csv}"
#	local db_farm_port="$4"
#	local hostname="$5"
	[[ $be_verbose ]] && echo "mclient -lsql -f $format -d $db_name -p $db_farm_port -h $hostname -s \"$query\""
	mclient -lsql -f $format -d $db_name -p $db_farm_port -h $hostname -s "$query" > /dev/null
}

function is_number {
	[[ "$1" =~ '^[0-9]+$' ]] && return 1 || return 0
}

function get_and_load_month_data {
	local year=$1
	local month=$2
	local url_prefix="http://tsdata.bts.gov/PREZIP/"
	local filename_prefix="On_Time_On_Time_Performance"
	local zip_file="${filename_prefix}_${year}_${month}.zip"
	local csv_file="${zip_file/zip/csv}"
	pushd $download_dir > /dev/null
	[[ "$be_verbose" ]] && echo "wget -c -q \"${url_prefix}${zip_file}\""
	wget -c -q "${url_prefix}${zip_file}" 2>&1;
	[[ "$be_verbose" ]] && echo "unzip -q -o \"$zip_file\" \"$csv_file\""
	unzip -q -o "$zip_file" "$csv_file" 2>&1

	[[ "$empty_as_null" ]] && null_as_clause=" NULL AS ''"
	# Note: For MonetDB, the OFFSET value in COPY INTO statements 
	# really means "start with the record whose 1-based index is, 
	# i.e. OFFSET 2 means skip the first record
	run_mclient "COPY OFFSET 2 INTO $table_name FROM '$download_dir/$csv_file' USING DELIMITERS ',','\n','\"' ${null_as_clause};"
	rm "$csv_file" 2>&1
	[[ $keep_downloads ]] || rm "$zip_file"
	popd > /dev/null
}

#------------------------------

schema_creation_sql='CREATE TABLE ontime ( Year_ INT NOT NULL, Quarter TINYINT NOT NULL, Month_ TINYINT NOT NULL, DayofMonth TINYINT NOT NULL, DayOfWeek TINYINT NOT NULL, FlightDate DATE NOT NULL, UniqueCarrier VARCHAR(7) NOT NULL, AirlineID INT NOT NULL, Carrier VARCHAR(2) NOT NULL, TailNum VARCHAR(50) DEFAULT NULL, FlightNum VARCHAR(10) NOT NULL, OriginAirportID INT DEFAULT NULL, OriginAirportSeqID INT NOT NULL, OriginCityMarketID INT NOT NULL, Origin VARCHAR(5) NOT NULL, OriginCityName VARCHAR(100) NOT NULL, OriginState VARCHAR(2) DEFAULT NULL, OriginStateFips VARCHAR(10) DEFAULT NULL, OriginStateName VARCHAR(100) DEFAULT NULL, OriginWac INT NOT NULL, DestAirportID INT NOT NULL, DestAirportSeqID INT NOT NULL, DestCityMarketID INT NOT NULL, Dest VARCHAR(5) NOT NULL, DestCityName VARCHAR(100) NOT NULL, DestState VARCHAR(2) DEFAULT NULL, DestStateFips VARCHAR(10) DEFAULT NULL, DestStateName VARCHAR(100) DEFAULT NULL, DestWac INT NOT NULL, CRSDepTime INT NOT NULL, DepTime INT DEFAULT NULL, DepDelay INT DEFAULT NULL, DepDelayMinutes INT DEFAULT NULL, DepDel15 INT DEFAULT NULL, DepartureDelayGroups INT DEFAULT NULL, DepTimeBlk VARCHAR(20) NOT NULL, TaxiOut INT DEFAULT NULL, WheelsOff INT DEFAULT NULL, WheelsOn INT DEFAULT NULL, TaxiIn INT DEFAULT NULL, CRSArrTime INT NOT NULL, ArrTime INT DEFAULT NULL, ArrDelay INT DEFAULT NULL, ArrDelayMinutes INT DEFAULT NULL, ArrDel15 INT DEFAULT NULL, ArrivalDelayGroups INT DEFAULT NULL, ArrTimeBlk VARCHAR(20) NOT NULL, Cancelled TINYINT NOT NULL, CancellationCode VARCHAR(1) DEFAULT NULL, Diverted TINYINT NOT NULL, CRSElapsedTime INT DEFAULT NULL, ActualElapsedTime INT DEFAULT NULL, AirTime INT DEFAULT NULL, Flights INT NOT NULL, Distance INT NOT NULL, DistanceGroup TINYINT NOT NULL, CarrierDelay INT DEFAULT NULL, WeatherDelay INT DEFAULT NULL, NASDelay INT DEFAULT NULL, SecurityDelay INT DEFAULT NULL, LateAircraftDelay INT DEFAULT NULL, FirstDepTime VARCHAR(10) DEFAULT NULL, TotalAddGTime VARCHAR(10) DEFAULT NULL, LongestAddGTime VARCHAR(10) DEFAULT NULL, DivAirportLandings VARCHAR(10) DEFAULT NULL, DivReachedDest VARCHAR(10) DEFAULT NULL, DivActualElapsedTime VARCHAR(10) DEFAULT NULL, DivArrDelay VARCHAR(10) DEFAULT NULL, DivDistance VARCHAR(10) DEFAULT NULL, Div1Airport VARCHAR(10) DEFAULT NULL, Div1AirportID INt DEFAULT NULL, Div1AirportSeqID INT DEFAULT NULL, Div1WheelsOn VARCHAR(10) DEFAULT NULL, Div1TotalGTime VARCHAR(10) DEFAULT NULL, Div1LongestGTime VARCHAR(10) DEFAULT NULL, Div1WheelsOff VARCHAR(10) DEFAULT NULL, Div1TailNum VARCHAR(10) DEFAULT NULL, Div2Airport VARCHAR(10) DEFAULT NULL, Div2AirportID INt DEFAULT NULL, Div2AirportSeqID INT DEFAULT NULL, Div2WheelsOn VARCHAR(10) DEFAULT NULL, Div2TotalGTime VARCHAR(10) DEFAULT NULL, Div2LongestGTime VARCHAR(10) DEFAULT NULL, Div2WheelsOff VARCHAR(10) DEFAULT NULL, Div2TailNum VARCHAR(10) DEFAULT NULL, Div3Airport VARCHAR(10) DEFAULT NULL, Div3AirportID INt DEFAULT NULL, Div3AirportSeqID INT DEFAULT NULL, Div3WheelsOn VARCHAR(10) DEFAULT NULL, Div3TotalGTime VARCHAR(10) DEFAULT NULL, Div3LongestGTime VARCHAR(10) DEFAULT NULL, Div3WheelsOff VARCHAR(10) DEFAULT NULL, Div3TailNum VARCHAR(10) DEFAULT NULL, Div4Airport VARCHAR(10) DEFAULT NULL, Div4AirportID INt DEFAULT NULL, Div4AirportSeqID INT DEFAULT NULL, Div4WheelsOn VARCHAR(10) DEFAULT NULL, Div4TotalGTime VARCHAR(10) DEFAULT NULL, Div4LongestGTime VARCHAR(10) DEFAULT NULL, Div4WheelsOff VARCHAR(10) DEFAULT NULL, Div4TailNum VARCHAR(10) DEFAULT NULL, Div5Airport VARCHAR(10) DEFAULT NULL, Div5AirportID INt DEFAULT NULL, Div5AirportSeqID INT DEFAULT NULL, Div5WheelsOn VARCHAR(10) DEFAULT NULL, Div5TotalGTime VARCHAR(10) DEFAULT NULL, Div5LongestGTime VARCHAR(10) DEFAULT NULL, Div5WheelsOff VARCHAR(10) DEFAULT NULL, Div5TailNum VARCHAR(10) DEFAULT NULL ); '


#------------------------------
# Parse command line here
#

while [[ $# > 0 ]]; do
	option_key="$1"
	
	case $option_key in
	-h|--help)
		usage;
		exit;
		;;
	-v|--verbose)
		be_verbose=1
		;;
	-r|--recreate)
		recreate_db=1
		;;
	-a|--append)
		append_to_db=1
		;;
	--first-month)
		first_month="$2"
		shift # past argument
		;;
	--last-month)
		last_month="$2"
		shift # past argument
		;;
	--first-year)
		first_year="$2"
		shift # past argument
		;;
	--last-year)
		last_year="$2"
		shift # past argument
		;;
	-d|--dbname|--db-name|--database-name)
		db_name="$2"
		shift # past argument
		;;
	-f|--farm|--db-farm|--dbfarm|--database-farm)
		db_farm="$2"
		shift # past argument
		;;
	-p|--port|--dbfarm-port)
		db_farm_port="$2"
		shift # past argument
		is_positive_int $db_farm_port || die "Invalid DB farm port $db_farm_port"
		;;
	-D|--download-to|--download-dir|-dl-dir|--download-directory)
		download_dir="$2"
		shift # past argument
		;;
	-k|--keep-downloaded|--keep|--keep-downloads)
		keep_downloads=1
		;;
	*) # unknown option
		die "Uknown command line option $option_key"
		;;
	esac
	shift # past argument or value
done
if [[ $# > 0 ]]; then
	usage
	exit -1
fi

if [[ ! "$first_year" ]]; then
	first_year=$first_year_with_data
fi

if [[ ! "$first_month" ]]; then
	first_month=$((first_year == first_year_with_data ? first_month_with_data : 1 ))
fi

if [[ ! "$last_year" ]]; then
	last_year=$last_year_with_data
fi

if [[ ! "$last_month" ]]; then
	last_month=$((last_year == last_year_with_data ? last_month_with_data : 12 ))
fi

if ! is_number $first_year || ! is_number $last_year || ! is_number $first_month || ! is_number $last_month; then
	die "Invalid year-month range ${first_year}-$first_month - ${last_year}-$last_month"
fi

if (( first_year > last_year || ( first_year == last_year && first_month > last_month ) )); then
	die "Invalid year-month range ${first_year}-$first_month - ${last_year}-$last_month"
fi

if ((first_year < first_year_with_data || (first_year == first_year_with_data && first_month < first_month_with_data) )); then
	die "No data is available from before month $first_month_with_data of year $first_year_with_data"
fi
if ((last_year > last_year_with_data || (last_year == last_year_with_data && last_month > last_month_with_data) )); then
	die "No data is available after year $last_year_with_data month $last_month_with_data (assuming a ${publication_delay_months}-month publication delay)"
fi

[[ "$be_verbose" ]] && echo "Will load monthly data from year $first_year month $first_month until year $last_year month ${last_month}, inclusive"

[[ -n "$db_farm" ]] || db_farm="$DB_FARM"
[[ -n "$db_farm" ]] || db_farm="$DBFARM"
[[ -n "$db_farm" ]] || die "A DB farm (= the directory in which to store the benchmark DB in a subdirectory) must be specified, either on the command-line (--db-farm) or in an environment variable (\$DB_FARM or \$DBFARM)"

# Command-line parsing complete

# Check for binaries

for binary in monetdbd monetdb; do
	[[ -n `which $binary` ]] || die "Missing MonetDB binary $binary"
done

# Note: We don't really need that extra space, but... better be on the safe side (especially if the .tbl directory and the DB farm are on the same partition)

total_months=$((last_month + (last_year - 1 - first_year) * 12))
necessary_space_in_mb=$(( estimated_space_per_month_mb * $total_months ))
# (note: not checking for enough space for the individual CSV files)
(( $(mb_available_space_for_dir $db_farm) > $necessary_space_in_mb )) ||
die "Not enough disk space at $db_farm to load the data: We need ${necessary_space_in_mb} MiB but have $(mb_available_space_for_dir $db_farm) MiB."

[[ -d $db_farm ]] || mkdir -p $db_farm || die "Failed creating a directory for the DB farm at $db_farm"

# Ensure we have a DB farm that's up in which to create the database - or try to create it

if db_farm_exists $db_farm; then
	db_farm_port=$(property_of_dbfarm "port" $db_farm)
	db_farm_is_up $db_farm || monetdbd start $db_farm || die "Could not start the DB farm at $db_farm"
else
	[[ "$be_verbose" ]] && echo "monetdbd create $db_farm" 
	monetdbd create $db_farm || die "A MonetDB database farm does not exist at ${db_farm}, and cannot be created there."
	[[ -z $db_farm_port ]] || db_farm_port=50002
	[[ "$be_verbose" ]] && echo "monetdbd set port=$db_farm_port $db_farm"
	monetdbd set port=$db_farm_port $db_farm || die "Can't set the daemon port for new DB farm ${db_farm} to ${db_farm_port}."
	[[ "$be_verbose" ]] && echo "monetdbd start $db_farm"
	monetdbd start $db_farm || die 
fi

db_farm_is_up $db_farm || die "Could not get DB farm at $db_farm to the started state"

# So, do we actually need to create anything?

if db_exists "$db_name" "$db_farm_port"; then
	if db_is_up "$db_name"; then
		[[ "$be_verbose" ]] &&  echo "monetdb -p $db_farm_port stop $db_name"
		monetdb -p $db_farm_port stop $db_name  >/dev/null || die "Can't stop the existing DB named $db_name in DB farm $db_farm." 
	fi
	if [[ "$recreate_db" ]]; then 
		[[ "$be_verbose" ]] &&  echo "monetdb -p $db_farm_port destroy -f $db_name" 
		monetdb -p $db_farm_port destroy -f $db_name >/dev/null || die "Failed destroying the existing DB named $db_name in DB farm $db_farm."
		need_to_create_the_db=1
	elif [[ ! "$append_to_db" ]]; then
		die "A database named $db_name already exists in DB farm ${db_farm}, so giving up. Perhaps you wanted to recreate it or append to it?"
	fi
else
	need_to_create_the_db=1
fi

# Create the DB and SQL-create its schema 

if [[ "$need_to_create_the_db" ]]; then
	( 
	( [[ "$be_verbose" ]] && echo "monetdb -p $db_farm_port create $db_name" ; monetdb -p $db_farm_port create $db_name > /dev/null ) &&  
	( [[ "$be_verbose" ]] && echo "monetdb -p $db_farm_port release $db_name" ;  monetdb -p $db_farm_port release $db_name > /dev/null ) 
	) || die "Failed to create (and release) a database named $db_name in DB farm $db_farm for US Deptartment of Transport on-time performance data."
	[[ $empty_as_null ]] || schema_creation_sql=$(echo $schema_creation_sql | sed -r 's/INT DEFAULT NULL/INT NOT NULL DEFAULT 0/g; s/VARCHAR\(([0-9]+)\) DEFAULT NULL/VARCHAR(\1) NOT NULL DEFAULT '\'\''/g;')
	run_mclient "$schema_creation_sql"
fi

# Now download, decompress and load the data for each month into the DB
# (note: The month part of the filename is not 0-padded)
# (note: For 1987 we have the whole year)
[[ "$be_verbose" ]] && echo "mkdir -p $download_dir"
mkdir -p $download_dir
if (($first_year == $last_year)); then
	for ((month=$first_month;month<=$last_month;month++)); do
		get_and_load_month_data $first_year $month
	done
else
	for ((month=${first_month};month<=12;month++)); do
		get_and_load_month_data $first_year $month
	done;
	for ((year=first_year+1;year<last_year-1;year++)); do
		for ((month=1;month<=12;month++)); do
			get_and_load_month_data $year $month
		done;
	done;
	for ((month=1;month<=$last_month;month++)); do
		get_and_load_month_data $last_year $month
	done
fi
if [[ ! "$keep_downloads" ]]; then
	[[ "$be_verbose" ]] && echo "rmdir $download_dir"
	rmdir $download_dir
fi

